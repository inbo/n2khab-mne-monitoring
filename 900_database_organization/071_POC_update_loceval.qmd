---
title: "POC Data Re-Upload - loceval"
date: "2025-09-24"
format:
  html:
    toc: true
    html-math-method: katex
    code-fold: false
    embed-resources: true
knitr:
  opts_chunk:
    echo: true
---



# TODO

- `is_gw_activity` / `is_loceval_activity`
- `091_push_loceval_to_mnmgwdb.py` only on 070

  
```{sh sync-staging}
#| eval: false
pg_dump -U <backup_user> -h <host> -p <port> -d <database> -N tiger -N public -c > /tmp/<database>_db_dump.txt \
        && psql -U <database_user> -h <host> -p <port> -d <database>_staging -W < /tmp/<database>_db_dump.txt \
        && rm /tmp/<database>_db_dump.txt
```

## libraries and variables

```{r libraries}
# libraries
source("MNMLibraryCollection.R")
load_poc_common_libraries()
load_database_interaction_libraries()

# the database connection object
source("MNMDatabaseConnection.R")

# more specific database tools
source("MNMDatabaseToolbox.R")


# library("mapview") # debugging only
# mapviewOptions(platform = "mapdeck")

```


## info stream from POC

First, there is the `.RData` file.

```{r load-sample-rdata}
tic <- function(toc) round(Sys.time() - toc, 1)
toc <- Sys.time()
load_poc_rdata(reload = FALSE, to_env = parent.frame())
message(glue::glue("Good morning!
  Loading the POC data took {tic(toc)} seconds today."
))

```

Some code snippets, possibly modified on the way, were provided by Floris.

```{r source-code-snippets}
# TODO: check for changes on every update, e.g. with `meld`:
#       meld 020_fieldwork_organization/code_snippets.R 900_database_organization/050_snippet_selection.R

# Load some custom GRTS functions
# project_root <- find_root(is_git_root)
# source(file.path(project_root, "R/grts.R"))
# TODO: rebase once PR#5 gets merged
snippets_path <- "/data/git/n2khab-mne-monitoring_support"

toc <- Sys.time()
load_poc_code_snippets(snippets_path)
message(glue::glue(
  "... loading/executing the code snippets took {tic(toc)}s."
))
```


Finally, check that everything was loaded correctly.

```{r poc-checks}
verify_poc_objects()
```


## database connection


```{r connect-databases}
database <- "loceval"
config_filepath <- file.path("./inbopostgis_server.conf")
mirror <- "-staging"
# mirror <- ""


# connect loceval
locevaldb_mirror <- glue::glue("{database}{mirror}")

locevaldb <- connect_mnm_database(
  config_filepath,
  database_mirror = locevaldb_mirror
) 

message(glue::glue("connected: psql {locevaldb$shellstring}"))

```


## dump all data, for safety

```{r step-1-safety-dump}

now <- format(Sys.time(), "%Y%m%d%H%M")
# if (isFALSE(grepl("-staging", loceval_mirror))) {
#   loceval$dump_all(
#     here::here("dumps", glue::glue("safedump_{loceval$database}_{now}.sql")),
#     exclude_schema = c("tiger", "public")
#   )
# }

if (isFALSE(grepl("-staging", locevaldb_mirror))) {
  locevaldb$dump_all(
    here::here("dumps", glue::glue("poc_pre_update_{locevaldb$database}_{now}.sql")),
    exclude_schema = c("tiger", "public")
  )
}

```


# Gather and Upload - locevaldb

## database versioning

```{r version}

if (FALSE) {

  # manually set a new version
  version_tag <- "≤v0.11.0_poc0.13.1"
  # version_tag <- "v0.11.0_poc0.13.1"
  version_notes <- ""
  date_applied <- as.integer(format(Sys.time(), "%Y%m%d"))

  version_id <- locevaldb$tag_new_version(
    new_version_tag = version_tag,
    new_version_notes =  version_notes,
    new_date_applied = date_applied
  )

  # SELECT * FROM "metadata"."Versions";

} else {
  # per default, the latest version is taken
  version_id <- locevaldb$load_latest_version_id()
}

if (FALSE) {
  # ... ad hoc / testing: delete version again
  table_label <- "Versions"
  glue::glue("
  DELETE FROM {locevaldb$get_namestring(table_label)}
  WHERE version_tag = '{version_tag}'
    AND data_iteration = {data_iteration}
  ;
  ")
}


# TODO: I still have to make up my mind whether to archive everything.
#       For now, I will preliminarily keep it with an "archive_id" column.
```



# Protocols, Activities, TeamMembers

:::{callout-warning}
Any news?
Now is the chance!
:::



# Let's Do This

## prerequisite_lookups

```{r gather-lookups}
grouped_activity_lookup <- locevaldb$query_lookup(
  "GroupedActivities",
  characteristic_columns = c("activity_group", "activity")
)

n2khabstrata_lookup <- locevaldb$query_lookup(
  "N2kHabStrata",
  characteristic_columns = c("stratum")
)

```


```{r load-activities}

activity_groupid_lookup <- locevaldb$query_columns(
    "GroupedActivities",
    c("activity_group", "activity_group_id")
  ) %>%
  distinct()

field_activities <- locevaldb$query_table("GroupedActivities") %>%
  filter(is_loceval_activity, is_field_activity) %>%
  distinct(activity_group, activity)

```

## Replacements

TODO: consider temporarily reflecting replacements in locevaldb


## Sample Units
  
```{r assemble-sample-units}

sample_units <-
  fag_stratum_grts_calendar %>%
  common_current_calenderfilters() %>%
  distinct(
    scheme_moco_ps,
    stratum,
    grts_address
  ) %>%
  unnest(scheme_moco_ps) %>%
  # adding location attributes
  inner_join(
    scheme_moco_ps_stratum_targetpanel_spsamples %>%
      select(
        scheme,
        module_combo_code,
        panel_set,
        stratum,
        grts_join_method,
        grts_address,
        grts_address_final,
        # retaining 3 cols that drive subsampling location(s) in the unit:
        is_forest,
        in_mhq_samples,
        last_type_assessment,
        last_type_assessment_in_field,
        domain_part,
        targetpanel
      ) %>%
      # deduplicating 7220:
      distinct(),
    join_by(scheme, module_combo_code, panel_set, stratum, grts_address),
    relationship = "many-to-one",
    unmatched = c("error", "drop")
  ) %>% 
  # also join the spatial poststratum, since we need this in setting
  # GRTS-address based priorities
  inner_join(
    scheme_moco_ps_stratum_sppost_spsamples %>%
      unnest(sp_poststr_samples) %>%
      select(-sample_status),
    join_by(scheme, module_combo_code, panel_set, stratum, grts_address),
    relationship = "many-to-one",
    unmatched = c("error", "drop")
  ) %>%
  select(-module_combo_code, -sp_poststratum) %>%
  nest_scheme_ps_targetpanel() %>%
  # # add MHQ assessment metadata
  # inner_join(
  #   stratum_grts_n2khab_phabcorrected_no_replacements %>%
  #     select(stratum, grts_address, assessed_in_field, assessment_date),
  #   join_by(stratum, grts_address),
  #   relationship = "many-to-one",
  #   unmatched = c("error", "drop")
  # ) %>%
  distinct() %>%
  # database-related additions 
  # convert_stratum_to_type() %>%
  rename_grts_address_final_to_grts_address() %>%
  rename(
    has_mhq_assessment = last_type_assessment_in_field,
    mhq_assessment_date = last_type_assessment 
  ) %>%
  relocate(grts_address) %>%
  relocate(grts_join_method, .after = grts_address) %>%
  mutate(
    previous_notes = NA # FUTURE TODO
  ) %>%
  mutate(
    across(c(
        grts_join_method,
        scheme_ps_targetpanels,
        # sp_poststratum,
        stratum,
        domain_part,
        previous_notes
      ),
      as.character
    )
  ) 

sample_units %>%
  filter(grts_address == 22107438) %>%
  t() %>% knitr::kable()

sample_units %>%
  filter(grts_address == 47764190) %>%
  t() %>% knitr::kable()

```


## Locations

```{r assemble-locations}

locations <- bind_rows(
    locevaldb$query_columns("Locations", c("grts_address")),
    sample_units %>% select(grts_address),
    locevaldb$query_columns("LocationInfos", c("grts_address")),
    locevaldb$query_columns("LocationAssessments", c("grts_address")),
    locevaldb$query_columns("FieldActivityCalendar", c("grts_address")),
    locevaldb$query_columns("Visits", c("grts_address")),
    locevaldb$query_columns("Replacements", c("grts_address_replacement", "is_selected")) %>% 
      filter(is_selected) %>%
      select(-is_selected) %>% 
      rename(grts_address = grts_address_replacement)
  ) %>%
  mutate(grts_address = as.integer(grts_address)) %>%
  distinct() %>%
  # count(grts_address) %>%
  # arrange(desc(n))
  add_point_coords_grts(
    grts_var = "grts_address",
    spatrast = grts_mh,
    spatrast_index = grts_mh_index
  )

sf::st_geometry(locations) <- "wkb_geometry"


table_label <- "Locations"
data_future <- locations %>% sf::st_drop_geometry()# %>% select(-wkb_geometry)
index_column <- locevaldb$get_primary_key(table_label)
characteristic_columns <- c("grts_address")

distribution <- categorize_data_update(
  mnmdb = locevaldb,
  table_label = table_label,
  data_future = data_future,
  input_precedence_columns = precedence_columns[[table_label]],
  characteristic_columns = characteristic_columns,
  exclude_columns = c("wkb_geometry")
)
print_category_count(distribution, table_label)

```


```{r update-locations}

locations_lookup <- just_do_it(
  mnmdb = locevaldb,
  table_label = table_label,
  distribution = distribution,
  index_columns = c(index_column),
  characteristic_columns = characteristic_columns,
  skip = list("update" = FALSE, "upload" = FALSE, "archive" = TRUE)
)


```


... and wait.
... and wait.
... and wait.

```{r reconnect-locations-to-sampleunits}

stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "SampleUnits",
  reference_table = "Locations",
  link_key_column = "location_id",
  lookup_columns = c("grts_address")
)

```

## Sample Locations

```{r porcess-sample-locations}

if ("location_id" %in% names(sample_units)) {
  # should not be the case in a continuous script;
  # this is extra safety for debugging and de-serial execution
  sample_units <- sample_units %>%
    select(-location_id)#, -location_id.x, -location_id.y)
}
sample_units <- sample_units %>%
  left_join(
    locations_lookup,
    by = join_by(grts_address),
    relationship = "many-to-one"
  ) %>%
  distinct()

# sample_units %>%
#   filter(grts_address == 22107438) %>%
#   t() %>% knitr::kable()

table_label <- "SampleUnits"
data_future <- sample_units %>%
  rename(type = stratum)
characteristic_columns <- c("grts_address", "type") # , "location_id"
index_column <- locevaldb$get_primary_key(table_label)
# locevaldb$query_columns(table_label, characteristic_columns)

distribution <- categorize_data_update(
  mnmdb = locevaldb,
  table_label = table_label,
  data_future = data_future,
  input_precedence_columns = precedence_columns[[table_label]],
  characteristic_columns = characteristic_columns,
)
print_category_count(distribution, table_label)

# distribution$to_archive
# distribution$reactivate
# distribution$to_upload

```


```{r update-sample-locations}

distribution$to_upload <- distribution$to_upload %>% 
  mutate(
    # log_user = "maintenance",
    # log_update = as.POSIXct(Sys.time()),
    replacement_ongoing = FALSE,
    is_replaced = FALSE,
    type_is_absent = FALSE
  ) 

# distribution$changed %>% t() %>% knitr::kable()
distribution$to_upload %>% select(!!!characteristic_columns) %>% knitr::kable()
distribution$to_upload %>% filter(grts_address == 47764190) %>% t() %>% knitr::kable()
# locevaldb$query_table("SampleUnits") %>%
#   semi_join(
#     distribution$changed,
#     by = join_by(grts_address)
#   ) %>% knitr::kable()

sampleunits_lookup <- just_do_it(
  mnmdb = locevaldb,
  table_label = table_label,
  distribution = distribution,
  index_columns = c(index_column),
  characteristic_columns = characteristic_columns,
  skip = list("update" = FALSE, "upload" = FALSE, "archive" = FALSE)
)


```




## FieldActivityCalendar

```{sql there-be-duplicates-1}
#| eval: false
#| echo: false

SELECT * FROM (
SELECT DISTINCT
  grts_address, type,
  COUNT(DISTINCT sampleunit_id) AS n
FROM "outbound"."FieldActivityCalendar"
GROUP BY grts_address, type
) WHERE n > 1;

SELECT * FROM (
SELECT DISTINCT
  grts_address, type,
  COUNT(DISTINCT sampleunit_id) AS n
FROM "inbound"."Visits"
GROUP BY grts_address, type
) WHERE n > 1;


SELECT * FROM (
SELECT DISTINCT
  grts_address, type, activity_group_id, date_start,
  string_agg(distinct CAST(visit_id AS VARCHAR), '|') as ids,
  COUNT(*) AS n
FROM "inbound"."Visits"
GROUP BY grts_address, type, activity_group_id, date_start
) WHERE n > 1;


FROM "inbound"."Visits"

SELECT * 
FROM "outbound"."FieldActivityCalendar"
WHERE (CAST(fieldactivitycalendar_id AS VARCHAR) IN (
  SELECT DISTINCT fieldactivitycalendar_id FROM (
    SELECT *, UNNEST(STRING_TO_ARRAY(ids, '|')) AS fieldactivitycalendar_id
    FROM (
    SELECT DISTINCT
      grts_address, type, activity_group_id, date_start,
      STRING_AGG(distinct CAST(fieldactivitycalendar_id AS VARCHAR), '|') as ids,
      -- MAX(fieldactivitycalendar_id) AS max_id,
      COUNT(*) AS n
    FROM "outbound"."FieldActivityCalendar"
    GROUP BY grts_address, type, activity_group_id, date_start
    )
    WHERE n > 1
  ) GROUP BY fieldactivitycalendar_id
))
AND NOT done_planning
ORDER BY fieldactivitycalendar_id ASC
;

- 914


SELECT *
FROM "outbound"."FieldActivityCalendar"
WHERE grts_address = 4344585
  AND fieldactivitycalendar_id NOT IN (
    SELECT DISTINCT fieldactivitycalendar_id
    FROM "inbound"."Visits"
    GROUP BY fieldactivitycalendar_id
  )
;

```


```{r assemble-field-activity-calendar}

fieldwork_calendar <-
  fieldwork_2025_prioritization_by_stratum %>%
  common_current_calenderfilters() %>% # should be filtered already!
  rename_grts_address_final_to_grts_address() %>%
  relocate(grts_address) %>%
  rename(type = stratum) %>%
  inner_join(
    sampleunits_lookup,
    by = join_by(grts_address, type),
    relationship = "many-to-one"
  ) %>%
  relocate(sampleunit_id) %>%
  rename(
    activity_rank = rank,
    activity_group = field_activity_group
  ) %>%
  semi_join(field_activities, by = join_by(activity_group)) %>%
  left_join(
    activity_groupid_lookup,
    by = join_by(activity_group),
    relationship = "many-to-one"
  ) %>%
  select(-activity_group) %>%
  mutate(
    across(c(
        type,
        grts_join_method,
        date_interval,
        domain_part,
        date_interval
      ),
      as.character
    )
  ) %>%
  # rename(stratum_scheme_ps_targetpanels = scheme_ps_targetpanels) %>% 
  mutate(
    log_user = "maintenance",
    log_update = as.POSIXct(Sys.time()),
    excluded = FALSE,
    no_visit_planned = FALSE,
    done_planning = FALSE
  ) 


fieldwork_calendar_new <- fieldwork_calendar %>%
  select(
    -grts_join_method,
    -scheme_ps_targetpanels,
    -domain_part,
    -is_forest,
    -in_mhq_samples,
    -last_type_assessment_in_field
  )

fieldcalendar_characols <- c(
    "grts_address",
    "type", 
    "activity_group_id",
    "date_start"
  )

# "sampleunit_id",
# "sspstapa_id",

```


```{r stitch-fwcal-to-slocs}

# link FieldworkCalender back to SampleUnits
stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "FieldActivityCalendar",
  reference_table = "SampleUnits",
  link_key_column = "sampleunit_id",
  lookup_columns = c("grts_address", "type")
)

```



```{r categorize-fieldworkcalendar}

table_label <- "FieldActivityCalendar"
data_future <- fieldwork_calendar_new
characteristic_columns <- fieldcalendar_characols
index_column <- locevaldb$get_primary_key(table_label)

distribution <- categorize_data_update(
  mnmdb = locevaldb,
  table_label = table_label,
  data_future = data_future,
  input_precedence_columns = precedence_columns[[table_label]],
  characteristic_columns = characteristic_columns,
)
print_category_count(distribution, table_label)

```


```{r check-the-news}
#| eval: false

distribution$to_archive %>%
  select(activity_group_id) %>%
  distinct() %>%
  left_join(
    activity_groupid_lookup,
    by = join_by(activity_group_id)
  )

```


```{r sync-fieldworkcalendar}

distribution$to_upload <- distribution$to_upload %>% 
  mutate(
    log_user = "maintenance",
    log_update = as.POSIXct(Sys.time()),
    excluded = FALSE,
    no_visit_planned = FALSE,
    done_planning = FALSE
  ) 


fieldworkcalendar_lookup <- just_do_it(
  mnmdb = locevaldb,
  table_label = table_label,
  distribution = distribution,
  index_columns = c(index_column),
  characteristic_columns = characteristic_columns,
  skip = list("update" = FALSE, "upload" = FALSE, "archive" = FALSE)
)


```


stitch sampleunit_id

```{r re-inspect-fieldworkcalendar}


locevaldb$query_table("FieldActivityCalendar") %>% 
  count(is.na(sampleunit_id)) %>%
  knitr::kable()

# compare stored to true sample location
locevaldb$query_table("FieldActivityCalendar") %>%
  left_join(
    locevaldb$query_table("SampleUnits"),
    by = join_by(grts_address, type)
  ) %>%
  filter(sampleunit_id.x != sampleunit_id.y)

```


## Visits

```{r stitch-visits}

# link Visits back to upstream tables
stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "Visits",
  reference_table = "FieldActivityCalendar",
  link_key_column = "fieldactivitycalendar_id",
  lookup_columns = c("grts_address", "type", "activity_group_id", "date_start")
)

stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "Visits",
  reference_table = "SampleUnits",
  link_key_column = "sampleunit_id",
  lookup_columns = c("grts_address", "type")
)

stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "Visits",
  reference_table = "Locations",
  link_key_column = "location_id",
  lookup_columns = c("grts_address")
)

```


```{r there-be-duplicates-2}
#| eval: false
#| echo: false
SELECT * FROM (
SELECT DISTINCT
  grts_address, type, activity_group_id, date_start,
  string_agg(distinct CAST(fieldactivitycalendar_id AS VARCHAR), '|') as ids,
  COUNT(*) AS n
FROM "outbound"."FieldActivityCalendar"
GROUP BY grts_address, type, activity_group_id, date_start
) WHERE n > 1;


SELECT * FROM (
SELECT DISTINCT
  grts_address, type, activity_group_id, date_start,
  COUNT(*) AS n
FROM "inbound"."Visits"
GROUP BY grts_address, type, activity_group_id, date_start
) WHERE n > 1;

e.g. 22107438 3110_1_5 19 2025-05-01
FROM "inbound"."Visits"
SELECT *
FROM "outbound"."FieldActivityCalendar"
WHERE (grts_address = 22107438)
AND (type = '3110_1_5')
AND (activity_group_id = 19)
AND (date_start = '2025-05-01')
;

FROM "outbound"."FieldActivityCalendar"
SELECT *
FROM "inbound"."Visits"
WHERE (grts_address = 2349833)
AND (stratum = '6430_mr')
AND (activity_group_id = 18)
AND (date_start = '2025-05-01')
;


fieldwork_calendar %>% 
  filter(
   grts_address == 22107438,
   type == '3110_1_5',
   activity_group_id == 19,
   date_start == as.Date('2025-05-01')
   ) %>% t() %>% knitr::kable()


locevaldb$query_table("FieldActivityCalendar") %>% 
  filter(
   grts_address == 22107438,
   type == '3110_1_5',
   activity_group_id == 19,
   date_start == as.Date('2025-05-01')
   ) %>% t() %>% knitr::kable()



```



```{r assemble-new-visits}

update_cascade_lookup <- parametrize_cascaded_update(locevaldb)

visits_characols <- c("fieldactivitycalendar_id", fieldcalendar_characols)

potential_visits <- fieldworkcalendar_lookup %>%
  select(
    !!!rlang::syms(visits_characols)
  ) %>%
  left_join(
    locations_lookup,
    by = join_by(grts_address)
  ) %>%
  mutate(
    log_user = "maintenance",
    log_update = as.POSIXct(Sys.time()),
    visit_done = FALSE
  )


visits_upload <- potential_visits %>%
  anti_join(
    locevaldb$query_table("Visits"),
    by = join_by(!!!rlang::syms(fieldcalendar_characols))
  ) %>%
  left_join(
    sampleunits_lookup,
    by = join_by(grts_address, type)
  )

visits_lookup <- update_cascade_lookup(
  table_label = "Visits",
  new_data = visits_upload,
  index_columns = c("visit_id"),
  characteristic_columns = visits_characols,
  tabula_rasa = FALSE,
  verbose = TRUE
)

locevaldb$query_table("Visits") %>% 
  count(is.na(fieldactivitycalendar_id)) %>%
  knitr::kable()

```


```{r reconnect-visits}

stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "Visits",
  reference_table = "SampleUnits",
  link_key_column = "sampleunit_id",
  lookup_columns = c("grts_address", "type"), 
  reference_mod = function(ref) ref %>% rename(stratum = strata)
)

stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "Visits",
  reference_table = "FieldActivityCalendar",
  link_key_column = "fieldactivitycalendar_id",
  lookup_columns = c("grts_address", "type", "activity_group_id", "date_start")
)


locevaldb$query_table("Visits") %>% 
  count(is.na(sampleunit_id), is.na(fieldactivitycalendar_id)) %>%
  knitr::kable()


```


archive visits of archived FWCals

```{r archive-visits-fwcal}
trgtab <- locevaldb$get_namestring("Visits")
srctab <- locevaldb$get_namestring("FieldActivityCalendar")
link_key_column <- "archive_version_id"
lookup_criteria <- c("TRGTAB.fieldactivitycalendar_id = SRCTAB.fieldactivitycalendar_id")

update_string <- glue::glue("
  UPDATE {trgtab} AS TRGTAB
    SET
      {link_key_column} = SRCTAB.{link_key_column}
    FROM {srctab} AS SRCTAB
    WHERE
     ({paste0(lookup_criteria, collapse = ') AND (')})
  ;")

locevaldb$execute_sql(update_string)

locevaldb$query_table("FieldActivityCalendar") %>%
  anti_join(
    locevaldb$query_table("Visits"),
    by = join_by(fieldactivitycalendar_id, archive_version_id)
  ) %>% nrow()


if (FALSE) {
  table_label <- "Visits"
  visits_redownload <- locevaldb$query_table(table_label) %>% 
    filter(is.na(archive_version_id)) %>%
    select(-archive_version_id)
  
  fwcal_lookup <- locevaldb$query_table("FieldActivityCalendar") %>% 
    filter(!is.na(archive_version_id)) %>%
    select(fieldactivitycalendar_id, archive_version_id)
  
  visits_archive <- visits_redownload %>%
    left_join(fwcal_lookup, by = join_by(fieldactivitycalendar_id)) %>%
    select(visit_id, archive_version_id) %>%
    filter(!is.na(archive_version_id))
  
  update_existing_data(
    mnmdb = locevaldb,
    table_label = table_label,
    changed_data = visits_archive,
    input_precedence_columns = precedence_columns[[table_label]],
    reference_columns = c(locevaldb$get_primary_key(table_label))
  )
}

```



## LocationInfos

```{r update-locationinfos}

new_locinfos <- sample_units %>%
  distinct(
    grts_address
  ) %>%
  mutate(
    log_creator = "maintenance",
    log_creation = as.POSIXct(Sys.time()),
    log_user = "maintenance",
    log_update = as.POSIXct(Sys.time())
  )

new_locinfos <- new_locinfos %>%
  anti_join(
    locevaldb$query_table("LocationInfos"),
    by = join_by(grts_address)
  ) %>%
  left_join(
    locations_lookup,
    by = join_by(grts_address),
  )


locationinfo_lookup <- update_cascade_lookup(
  table_label = "LocationInfos",
  new_data = new_locinfos,
  index_columns = c("locationinfo_id"),
  characteristic_columns = c("grts_address"),
  tabula_rasa = FALSE,
  verbose = TRUE
)


```


```{r update-landuse}

landuse <- readRDS("data/landuse_export.rds")

# forestry_area, # bosbeheerregio
# fores_naam, # bosbeheer
# np_type, # natuurpunt
# lila_statuut,
# durme_reservaat,
# perc_rbh, # percelen // rbh
# perc_naameig, # naam eigenaar
# nbhp_type, # natuurbeheerplan
# gewasgroep, # landbouw
# lblhfdtlt # landbouw

landinfo <- landuse %>%
  mutate(anb = stringr::str_c("ANB: ", anb_rights)) %>%
  mutate(mil = stringr::str_c("MIL: ", mdbd_naam, " (", mdbd_inbo, ")")) %>%
  mutate(bos = stringr::str_c("BOS: ", forestry_area, " (", fores_naam, ")")) %>%
  mutate(np = stringr::str_c("NP: ", np_type)) %>%
  mutate(lila = stringr::str_c("LILA: ", lila_statuut)) %>%
  mutate(durme = stringr::str_c("DURME: ", durme_reservaat)) %>%
  mutate(perc = stringr::str_c("PERC: ", perc_rbh, " (", perc_naameig, ")")) %>%
  mutate(nbhp = stringr::str_c("NBHP: ", nbhp_type)) %>%
  mutate(lb = stringr::str_c("LB: ", gewasgroep, " (", lblhfdtlt, ")")) %>%
  tidyr::unite(landuse, c(
      anb, mil, bos,
      np, lila, durme,
      perc, nbhp, lb
    ),
    sep = ", ",
    na.rm = TRUE
  ) %>%
  distinct(
    # schemegroup,
    # stratum,
    grts_address,
    landuse
  ) %>%
  semi_join(
    locevaldb$query_columns("LocationInfos", c("grts_address")) %>%
    distinct(),
    by = join_by(grts_address)
  )

glimpse(landinfo)


get_update_row_string_landuse <- function(landinfo_rownr){

  grts <- landinfo[landinfo_rownr, "grts_address"]
  info <- landinfo[landinfo_rownr, "landuse"]
  if (is.na(info)) {
    info <- "NULL"
  }

  info <- glue::glue("'{info}'")

  target_namestring <- '"outbound"."LocationInfos"'
  update_string <- glue::glue("
    UPDATE {target_namestring}
      SET landowner = {info}
    WHERE grts_address = {grts}
    ;
  ")

  return(update_string)
}

# concatenate update rows
update_command <- lapply(
  seq_len(nrow(landinfo)),
  FUN = get_update_row_string_landuse
)

# spin up a progress bar
pb <- txtProgressBar(
  min = 0, max = nrow(landinfo),
  initial = 0, style = 1
)

# execute the update commands.
for (landinfo_rownr in 1:nrow(landinfo)) {
  setTxtProgressBar(pb, landinfo_rownr)
  cmd <- update_command[[landinfo_rownr]]
  locevaldb$execute_sql(cmd, verbose = FALSE)
}

close(pb) # close the progress bar
```



```{r step-n-safety-dump}

now <- format(Sys.time(), "%Y%m%d%H%M")
# if (isFALSE(grepl("-staging", loceval_mirror))) {
#   loceval$dump_all(
#     here::here("dumps", glue::glue("safedump_{loceval$database}_{now}.sql")),
#     exclude_schema = c("tiger", "public")
#   )
# }

if (isFALSE(grepl("-staging", locevaldb_mirror))) {
  locevaldb$dump_all(
    here::here("dumps", glue::glue("poc_post_update_{locevaldb$database}_{now}.sql")),
    exclude_schema = c("tiger", "public")
  )
}

```


```{r launch-consistency-dashboard}
system("quarto render 040_consistency_dashboard.qmd --to html")
```


## TODO

- [✓] re-run the procedure.
- [✓] WIA and CSA seem unlinked or visit_done is wrong?
  -> drop visit_done from WIA/CSA

- [✓] processing scripts: replacement!! -> test daily maintenance scripts

- [✓] LocationCells
- [✓] LocationInfos

- [✓] should I not add "replacements" above?

First Round: 
- [✓] as is

Second Round:
- [✓] adjust `common_current_calenderfilters()` -> 2026 data of certain activities

Third Round
- then re-download RData
- -> add new `wait_*` column
