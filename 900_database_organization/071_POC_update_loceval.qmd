---
title: "POC Data Re-Upload - loceval"
date: "2025-09-24"
format:
  html:
    toc: true
    html-math-method: katex
    code-fold: false
    embed-resources: true
knitr:
  opts_chunk:
    echo: true
---



# TODO

- `is_gw_activity` / `is_loceval_activity`
- `091_push_loceval_to_mnmgwdb.py` only on 070

  
```{sh sync-staging}
#| eval: false
pg_dump -U <backup_user> -h <host> -p <port> -d <database> -N tiger -N public -c > /tmp/<database>_db_dump.txt \
        && psql -U <database_user> -h <host> -p <port> -d <database>_staging -W < /tmp/<database>_db_dump.txt \
        && rm /tmp/<database>_db_dump.txt
```

## libraries and variables

```{r libraries}
# libraries
source("MNMLibraryCollection.R")
load_poc_common_libraries()
load_database_interaction_libraries()

# the database connection object
source("MNMDatabaseConnection.R")

# more specific database tools
source("MNMDatabaseToolbox.R")


# library("mapview") # debugging only
# mapviewOptions(platform = "mapdeck")

```


## info stream from POC

First, there is the `.RData` file.

```{r load-sample-rdata}
tic <- function(toc) round(Sys.time() - toc, 1)
toc <- Sys.time()
load_poc_rdata(reload = FALSE, to_env = parent.frame())
message(glue::glue("Good morning!
  Loading the POC data took {tic(toc)} seconds today."
))

```

Some code snippets, possibly modified on the way, were provided by Floris.

```{r source-code-snippets}
# TODO: check for changes on every update, e.g. with `meld`:
#       meld 020_fieldwork_organization/code_snippets.R 900_database_organization/050_snippet_selection.R

# Load some custom GRTS functions
# project_root <- find_root(is_git_root)
# source(file.path(project_root, "R/grts.R"))
# TODO: rebase once PR#5 gets merged
snippets_path <- "/data/git/n2khab-mne-monitoring_support"

toc <- Sys.time()
load_poc_code_snippets(snippets_path)
message(glue::glue(
  "... loading/executing the code snippets took {tic(toc)}s."
))
```


Finally, check that everything was loaded correctly.

```{r poc-checks}
verify_poc_objects()
```


## database connection


```{r connect-databases}
database <- "loceval"
config_filepath <- file.path("./inbopostgis_server.conf")
# mirror <- ""
mirror <- "-staging"


# connect loceval
locevaldb_mirror <- glue::glue("{database}{mirror}")

locevaldb <- connect_mnm_database(
  config_filepath,
  database_mirror = locevaldb_mirror
) 
# keyring::keyring_delete(keyring = "mnmdb_temp")

message(glue::glue("connected: psql {locevaldb$shellstring}"))
update_cascade_lookup <- parametrize_cascaded_update(locevaldb)

```


## dump all data, for safety

```{r step-1-safety-dump}

now <- format(Sys.time(), "%Y%m%d%H%M")
# if (isFALSE(grepl("-staging", loceval_mirror))) {
#   loceval$dump_all(
#     here::here("dumps", glue::glue("safedump_{loceval$database}_{now}.sql")),
#     exclude_schema = c("tiger", "public")
#   )
# }

if (isFALSE(grepl("-staging", locevaldb_mirror))) {
  locevaldb$dump_all(
    here::here("dumps", glue::glue("poc_pre_update_{locevaldb$database}_{now}.sql")),
    exclude_schema = c("tiger", "public")
  )
}

```


# Gather and Upload - locevaldb

## database versioning

```{r version}

if (FALSE) {

  # manually set a new version
  # version_tag <- "â‰¤v0.11.0_poc0.13.1"
  # version_tag <- "v0.12.0_poc0.14.0"
  version_tag <- "v0.12.0_poc0.14.0" # data_iteration = 2
  version_notes <- "de-activation inactive locations in Achterhaven Zeebrugge"
  date_applied <- as.integer(format(Sys.time(), "%Y%m%d"))

  version_id <- locevaldb$tag_new_version(
    new_version_tag = version_tag,
    new_version_notes =  version_notes,
    new_date_applied = date_applied
  )

  # SELECT * FROM "metadata"."Versions";

} else {
  # per default, the latest version is taken
  version_id <- locevaldb$load_latest_version_id()
}

if (FALSE) {
  # ... ad hoc / testing: delete version again
  table_label <- "Versions"
  glue::glue("
  DELETE FROM {locevaldb$get_namestring(table_label)}
  WHERE version_tag = '{version_tag}'
    AND data_iteration = {data_iteration}
  ;
  ")
  glue::glue("
  UPDATE {locevaldb$get_namestring(table_label)}
  SET notes = E'{version_notes}'
  WHERE version_tag = {version_tag}
    AND data_iteration = {data_iteration}
  ;
  ")

  # 'SELECT * FROM "metadata"."Versions";'
    
}


# TODO: I still have to make up my mind whether to archive everything.
#       For now, I will preliminarily keep it with an "archive_id" column.
```



# Protocols, Activities, TeamMembers

:::{callout-warning}
Any news?
Now is the chance!
:::



# Let's Do This

## prerequisite_lookups

```{r gather-lookups}
grouped_activity_lookup <- locevaldb$query_lookup(
  "GroupedActivities",
  characteristic_columns = c("activity_group", "activity")
)

n2khabstrata_lookup <- locevaldb$query_lookup(
  "N2kHabStrata",
  characteristic_columns = c("stratum")
)

```


```{r load-activities}

activity_groupid_lookup <- locevaldb$query_columns(
    "GroupedActivities",
    c("activity_group", "activity_group_id")
  ) %>%
  distinct()

field_activities <- locevaldb$query_table("GroupedActivities") %>%
  filter(is_loceval_activity, is_field_activity) %>%
  distinct(activity_group, activity)

```



## Sample Units
  
```{r assemble-sample-units}

sample_units <-
  fag_stratum_grts_calendar %>%
  common_current_calenderfilters() %>%
  distinct(
    scheme_moco_ps,
    stratum,
    grts_address
  ) %>%
  unnest(scheme_moco_ps) %>%
  # adding location attributes
  inner_join(
    scheme_moco_ps_stratum_targetpanel_spsamples %>%
      select(
        scheme,
        module_combo_code,
        panel_set,
        stratum,
        grts_join_method,
        grts_address,
        grts_address_final,
        # retaining 3 cols that drive subsampling location(s) in the unit:
        is_forest,
        in_mhq_samples,
        last_type_assessment,
        last_type_assessment_in_field,
        domain_part,
        targetpanel
      ) %>%
      # deduplicating 7220:
      distinct(),
    join_by(scheme, module_combo_code, panel_set, stratum, grts_address),
    relationship = "many-to-one",
    unmatched = c("error", "drop")
  ) %>% 
  # also join the spatial poststratum, since we need this in setting
  # GRTS-address based priorities
  inner_join(
    scheme_moco_ps_stratum_sppost_spsamples %>%
      unnest(sp_poststr_samples) %>%
      select(-sample_status),
    join_by(scheme, module_combo_code, panel_set, stratum, grts_address),
    relationship = "many-to-one",
    unmatched = c("error", "drop")
  ) %>%
  select(-module_combo_code, -sp_poststratum) %>%
  nest_scheme_ps_targetpanel() %>%
  # # add MHQ assessment metadata
  # inner_join(
  #   stratum_grts_n2khab_phabcorrected_no_replacements %>%
  #     select(stratum, grts_address, assessed_in_field, assessment_date),
  #   join_by(stratum, grts_address),
  #   relationship = "many-to-one",
  #   unmatched = c("error", "drop")
  # ) %>%
  distinct() %>%
  # database-related additions 
  # convert_stratum_to_type() %>%
  rename_grts_address_final_to_grts_address() %>%
  rename(
    has_mhq_assessment = last_type_assessment_in_field,
    mhq_assessment_date = last_type_assessment 
  ) %>%
  relocate(grts_address) %>%
  relocate(grts_join_method, .after = grts_address) %>%
  mutate(
    previous_notes = NA # FUTURE TODO
  ) %>%
  mutate(
    across(c(
        grts_join_method,
        scheme_ps_targetpanels,
        # sp_poststratum,
        stratum,
        domain_part,
        previous_notes
      ),
      as.character
    )
  ) 

# sample_units %>%
#   filter(grts_address == 22107438) %>%
#   t() %>% knitr::kable()
# 
# sample_units %>%
#   filter(grts_address == 47764190) %>%
#   t() %>% knitr::kable()

```


## Locations

```{r assemble-locations}

locations <- bind_rows(
    locevaldb$query_columns("Locations", c("grts_address")),
    sample_units %>% select(grts_address),
    locevaldb$query_columns("LocationInfos", c("grts_address")),
    locevaldb$query_columns("LocationAssessments", c("grts_address")),
    locevaldb$query_columns("FieldActivityCalendar", c("grts_address")),
    locevaldb$query_columns("Visits", c("grts_address")),
    locevaldb$query_columns("Replacements", c("grts_address_replacement", "is_selected")) %>% 
      filter(is_selected) %>%
      select(-is_selected) %>% 
      rename(grts_address = grts_address_replacement)
  ) %>%
  mutate(grts_address = as.integer(grts_address)) %>%
  distinct() %>%
  # count(grts_address) %>%
  # arrange(desc(n))
  add_point_coords_grts(
    grts_var = "grts_address",
    spatrast = grts_mh,
    spatrast_index = grts_mh_index
  )

sf::st_geometry(locations) <- "wkb_geometry"


table_label <- "Locations"
data_future <- locations %>% sf::st_drop_geometry()# %>% select(-wkb_geometry)
index_column <- locevaldb$get_primary_key(table_label)
characteristic_columns <- c("grts_address")

distribution <- categorize_data_update(
  mnmdb = locevaldb,
  table_label = table_label,
  data_future = data_future,
  input_precedence_columns = precedence_columns[[table_label]],
  characteristic_columns = characteristic_columns,
  exclude_columns = c("wkb_geometry")
)
print_category_count(distribution, table_label)

```


```{r update-locations}

locations_lookup <- just_do_it(
  mnmdb = locevaldb,
  table_label = table_label,
  distribution = distribution,
  index_columns = c(index_column),
  characteristic_columns = characteristic_columns,
  skip = list("update" = FALSE, "upload" = FALSE, "archive" = TRUE)
)


```


... and wait.
... and wait.
... and wait.

```{r reconnect-locations-to-sampleunits}

stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "SampleUnits",
  reference_table = "Locations",
  link_key_column = "location_id",
  lookup_columns = c("grts_address")
)

```

## Sample Locations

```{r porcess-sample-locations}

if ("location_id" %in% names(sample_units)) {
  # should not be the case in a continuous script;
  # this is extra safety for debugging and de-serial execution
  sample_units <- sample_units %>%
    select(-location_id)#, -location_id.x, -location_id.y)
}
sample_units <- sample_units %>%
  left_join(
    locevaldb$query_columns("Locations", c("grts_address", "location_id")),
    by = join_by(grts_address),
    relationship = "many-to-one"
  ) %>%
  distinct()

# sample_units %>%
#   filter(grts_address == 22107438) %>%
#   t() %>% knitr::kable()

table_label <- "SampleUnits"
data_future <- sample_units %>%
  rename(type = stratum)
characteristic_columns <- c("grts_address", "type") # , "location_id"
index_column <- locevaldb$get_primary_key(table_label)
# locevaldb$query_columns(table_label, characteristic_columns)

distribution <- categorize_data_update(
  mnmdb = locevaldb,
  table_label = table_label,
  data_future = data_future,
  input_precedence_columns = precedence_columns[[table_label]],
  characteristic_columns = characteristic_columns,
)
print_category_count(distribution, table_label)

# distribution$to_archive
# distribution$reactivate
# distribution$to_archive
# distribution$to_upload
# data_future %>% filter(grts_address == 48043282)
distribution$to_archive %>%
  select(grts_address, type) %>% 
  arrange(grts_address) %>% knitr::kable()
distribution$reactivate %>%
  select(grts_address, type) %>% 
  arrange(grts_address) %>% knitr::kable()
```

```{r detective-work}
#| eval: false

fag_stratum_grts_calendar %>%
  rename(type = stratum, grts_address_original = grts_address, grts_address = grts_address_final) %>% 
  semi_join(
    distribution$to_archive,
    by = join_by(grts_address, type)
  )


distribution$changed %>% knitr::kable()
```


```{r update-sample-locations}

distribution$to_upload <- distribution$to_upload %>% 
  mutate(
    # log_user = "maintenance",
    # log_update = as.POSIXct(Sys.time()),
    replacement_ongoing = FALSE,
    is_replaced = FALSE,
    type_is_absent = FALSE
  ) 

# distribution$changed %>% t() %>% knitr::kable()
# distribution$to_upload %>% select(!!!characteristic_columns) %>% knitr::kable()
# distribution$to_upload %>% filter(grts_address == 47764190) %>% t() %>% knitr::kable()
# locevaldb$query_table("SampleUnits") %>%
#   semi_join(
#     distribution$changed,
#     by = join_by(grts_address)
#   ) %>% knitr::kable()

sampleunits_lookup <- just_do_it(
  mnmdb = locevaldb,
  table_label = table_label,
  distribution = distribution,
  index_columns = c(index_column),
  characteristic_columns = characteristic_columns,
  skip = list("update" = FALSE, "upload" = FALSE, "archive" = FALSE)
)

```

## location cells

```{r new-location-cells}

units_cell_polygon[["grts_address_final"]] <-
  as.integer(units_cell_polygon[["grts_address_final"]])

# unit geometries (cells):
location_cells <-
  units_cell_polygon %>%
  inner_join(
    locations_lookup,
    by = join_by(grts_address_final == grts_address),
    relationship = "one-to-many",
    unmatched = "drop"
  ) %>%
  select(-grts_address_final) %>%
  relocate(geometry, .after = last_col())

sf::st_geometry(location_cells) <- "wkb_geometry"
# glimpse(location_cells)

message("________________________________________________________________")
message(glue::glue("DELETE/INSERT of metadata.LocationCells"))

locevaldb$execute_sql(
  glue::glue('DELETE  FROM "metadata"."LocationCells";'),
  verbose = TRUE
)

locevaldb$insert_data(
  table_label = "LocationCells",
  upload_data = location_cells
)

```



## FieldActivityCalendar

```{sql there-be-duplicates-1}
#| eval: false
#| echo: false

SELECT * FROM (
SELECT DISTINCT
  grts_address, type,
  COUNT(DISTINCT sampleunit_id) AS n
FROM "outbound"."FieldActivityCalendar"
GROUP BY grts_address, type
) WHERE n > 1;

SELECT * FROM (
SELECT DISTINCT
  grts_address, type,
  COUNT(DISTINCT sampleunit_id) AS n
FROM "inbound"."Visits"
GROUP BY grts_address, type
) WHERE n > 1;


SELECT * FROM (
SELECT DISTINCT
  grts_address, type, activity_group_id, date_start,
  string_agg(distinct CAST(visit_id AS VARCHAR), '|') as ids,
  COUNT(*) AS n
FROM "inbound"."Visits"
GROUP BY grts_address, type, activity_group_id, date_start
) WHERE n > 1;



FROM "outbound"."FieldActivityCalendar"
FROM "inbound"."Visits"


SELECT *
FROM "outbound"."FieldActivityCalendar"
WHERE fieldactivitycalendar_id IN (
  SELECT DISTINCT CAL.fieldactivitycalendar_id 
  FROM "outbound"."FieldActivityCalendar" AS CAL
  LEFT JOIN (
    SELECT fieldactivitycalendar_id, visit_done, date_visit, notes
    FROM "inbound"."Visits"
  ) AS VIS
    ON VIS.fieldactivitycalendar_id = CAL.fieldactivitycalendar_id
  WHERE (CAST(CAL.fieldactivitycalendar_id AS VARCHAR) IN (
    SELECT DISTINCT fieldactivitycalendar_id FROM (
      SELECT *, UNNEST(STRING_TO_ARRAY(ids, '|')) AS fieldactivitycalendar_id
      FROM (
      SELECT DISTINCT
        grts_address, type, activity_group_id, date_start,
        STRING_AGG(distinct CAST(fieldactivitycalendar_id AS VARCHAR), '|') as ids,
        COUNT(*) AS n
      FROM "outbound"."FieldActivityCalendar"
      GROUP BY grts_address, type, activity_group_id, date_start
      )
      WHERE n > 1
    ) GROUP BY fieldactivitycalendar_id
  ))
  AND VIS.fieldactivitycalendar_id IS NULL
  ORDER BY CAL.fieldactivitycalendar_id ASC
)
;


AND NOT done_planning
- 914


SELECT *
FROM "outbound"."FieldActivityCalendar"
WHERE grts_address = 4344585
  AND fieldactivitycalendar_id NOT IN (
    SELECT DISTINCT fieldactivitycalendar_id
    FROM "inbound"."Visits"
    GROUP BY fieldactivitycalendar_id
  )
;

```


```{r assemble-field-activity-calendar}

fieldwork_calendar <-
  fieldwork_2025_prioritization_by_stratum %>%
  common_current_calenderfilters() %>% # should be filtered already!
  rename_grts_address_final_to_grts_address() %>%
  relocate(grts_address) %>%
  rename(type = stratum) %>%
  inner_join(
    sampleunits_lookup,
    by = join_by(grts_address, type),
    relationship = "many-to-one"
  ) %>%
  relocate(sampleunit_id) %>%
  rename(
    activity_rank = rank,
    activity_group = field_activity_group
  ) %>%
  semi_join(field_activities, by = join_by(activity_group)) %>%
  left_join(
    activity_groupid_lookup,
    by = join_by(activity_group),
    relationship = "many-to-one"
  ) %>%
  select(-activity_group) %>%
  mutate(
    across(c(
        type,
        grts_join_method,
        date_interval,
        domain_part,
        date_interval
      ),
      as.character
    )
  ) %>%
  # rename(stratum_scheme_ps_targetpanels = scheme_ps_targetpanels) %>% 
  mutate(
    log_user = "maintenance",
    log_update = as.POSIXct(Sys.time()),
    excluded = FALSE,
    no_visit_planned = FALSE,
    done_planning = FALSE
  ) 

fieldwork_calendar %>% filter(grts_address == 1677870) %>% t() %>% knitr::kable()

fieldwork_calendar_new <- fieldwork_calendar %>%
  select(
    -grts_join_method,
    -scheme_ps_targetpanels,
    -domain_part,
    -is_forest,
    -in_mhq_samples,
    -last_type_assessment_in_field
  )

fieldcalendar_characols <- c(
    "grts_address",
    "type", 
    "activity_group_id",
    "date_start"
  )

# "sampleunit_id",
# "sspstapa_id",

```


```{r stitch-fwcal-to-sunits}

# link FieldworkCalender back to SampleUnits
stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "FieldActivityCalendar",
  reference_table = "SampleUnits",
  link_key_column = "sampleunit_id",
  lookup_columns = c("grts_address", "type")
)

```



```{r categorize-fieldworkcalendar}

table_label <- "FieldActivityCalendar"
data_future <- fieldwork_calendar_new
characteristic_columns <- fieldcalendar_characols
index_column <- locevaldb$get_primary_key(table_label)
# data_future %>% head(3) %>% t() %>% knitr::kable()
# data_future %>% filter(grts_address == 1677870) %>% t() %>% knitr::kable()

distribution <- categorize_data_update(
  mnmdb = locevaldb,
  table_label = table_label,
  data_future = data_future,
  input_precedence_columns = precedence_columns[[table_label]],
  characteristic_columns = characteristic_columns,
  exclude_columns = c("sampleunit_id") #, "fieldactivitycalendar_id") # , "archive_version_id"
)
print_category_count(distribution, table_label)

# distribution$to_archive %>% filter(grts_address == 3202741) %>% t() %>% knitr::kable()
# distribution$reactivate %>% filter(grts_address == 3202741) %>% t() %>% knitr::kable()
```


```{r check-the-news}
#| eval: false

distribution$to_archive %>%
  count(activity_group_id) %>%
  left_join(
    activity_groupid_lookup,
    by = join_by(activity_group_id)
  )

```


```{r sync-fieldworkcalendar}

distribution$to_upload <- distribution$to_upload %>% 
  mutate(
    log_user = "maintenance",
    log_update = as.POSIXct(Sys.time()),
    excluded = FALSE,
    no_visit_planned = FALSE,
    done_planning = FALSE
  ) 


fieldworkcalendar_lookup <- just_do_it(
  mnmdb = locevaldb,
  table_label = table_label,
  distribution = distribution,
  index_columns = c(index_column),
  characteristic_columns = characteristic_columns,
  skip = list("update" = FALSE, "upload" = FALSE, "archive" = FALSE)
)


```



```{r re-inspect-fieldworkcalendar}


locevaldb$query_table("FieldActivityCalendar") %>% 
  count(is.na(sampleunit_id)) %>%
  knitr::kable()

# compare stored to true sample location
locevaldb$query_table("FieldActivityCalendar") %>%
  left_join(
    locevaldb$query_table("SampleUnits"),
    by = join_by(grts_address, type)
  ) %>%
  filter(sampleunit_id.x != sampleunit_id.y)

```


## Visits

```{r stitch-visits}

# link Visits back to upstream tables
stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "Visits",
  reference_table = "FieldActivityCalendar",
  link_key_column = "fieldactivitycalendar_id",
  lookup_columns = c("grts_address", "type", "activity_group_id", "date_start")
)

stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "Visits",
  reference_table = "SampleUnits",
  link_key_column = "sampleunit_id",
  lookup_columns = c("grts_address", "type")
)

stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "Visits",
  reference_table = "Locations",
  link_key_column = "location_id",
  lookup_columns = c("grts_address")
)

```


```{r there-be-duplicates-2}
#| eval: false
#| echo: false
SELECT * FROM (
SELECT DISTINCT
  grts_address, type, activity_group_id, date_start,
  string_agg(distinct CAST(fieldactivitycalendar_id AS VARCHAR), '|') as ids,
  COUNT(*) AS n
FROM "outbound"."FieldActivityCalendar"
GROUP BY grts_address, type, activity_group_id, date_start
) WHERE n > 1;


SELECT * FROM (
SELECT DISTINCT
  grts_address, type, activity_group_id, date_start,
  COUNT(*) AS n
FROM "inbound"."Visits"
GROUP BY grts_address, type, activity_group_id, date_start
) WHERE n > 1;

e.g. 22107438 3110_1_5 19 2025-05-01
FROM "inbound"."Visits"
SELECT *
FROM "outbound"."FieldActivityCalendar"
WHERE (grts_address = 22107438)
AND (type = '3110_1_5')
AND (activity_group_id = 19)
AND (date_start = '2025-05-01')
;

FROM "outbound"."FieldActivityCalendar"
SELECT *
FROM "inbound"."Visits"
WHERE (grts_address = 2349833)
AND (type = '6430_mr')
AND (activity_group_id = 18)
AND (date_start = '2025-05-01')
;


fieldwork_calendar %>% 
  filter(
   grts_address == 22107438,
   type == '3110_1_5',
   activity_group_id == 19,
   date_start == as.Date('2025-05-01')
   ) %>% t() %>% knitr::kable()


locevaldb$query_table("FieldActivityCalendar") %>% 
  filter(
   grts_address == 22107438,
   type == '3110_1_5',
   activity_group_id == 19,
   date_start == as.Date('2025-05-01')
   ) %>% t() %>% knitr::kable()



```



```{r assemble-new-visits}


visits_characols <- c("fieldactivitycalendar_id", fieldcalendar_characols)

potential_visits <- fieldworkcalendar_lookup %>%
  select(
    !!!rlang::syms(visits_characols)
  ) %>%
  left_join(
    locations_lookup,
    by = join_by(grts_address)
  ) %>%
  mutate(
    log_user = "maintenance",
    log_update = as.POSIXct(Sys.time()),
    visit_done = FALSE
  )


visits_upload <- potential_visits %>%
  anti_join(
    locevaldb$query_table("Visits"),
    by = join_by(!!!rlang::syms(fieldcalendar_characols))
  ) %>%
  left_join(
    sampleunits_lookup,
    by = join_by(grts_address, type)
  )

visits_lookup <- update_cascade_lookup(
  table_label = "Visits",
  new_data = visits_upload,
  index_columns = c("visit_id"),
  characteristic_columns = visits_characols,
  tabula_rasa = FALSE,
  verbose = TRUE
)

locevaldb$query_table("Visits") %>% 
  count(is.na(fieldactivitycalendar_id)) %>%
  knitr::kable()

```


```{r reconnect-visits}

stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "Visits",
  reference_table = "SampleUnits",
  link_key_column = "sampleunit_id",
  lookup_columns = c("grts_address", "type") 
)

stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "Visits",
  reference_table = "FieldActivityCalendar",
  link_key_column = "fieldactivitycalendar_id",
  lookup_columns = c("grts_address", "type", "activity_group_id", "date_start")
)


locevaldb$query_table("Visits") %>% 
  count(is.na(sampleunit_id), is.na(fieldactivitycalendar_id)) %>%
  knitr::kable()


```


archive visits of archived FWCals

```{r archive-visits-fwcal}
trgtab <- locevaldb$get_namestring("Visits")
srctab <- locevaldb$get_namestring("FieldActivityCalendar")
link_key_column <- "archive_version_id"
lookup_criteria <- c("TRGTAB.fieldactivitycalendar_id = SRCTAB.fieldactivitycalendar_id")

update_string <- glue::glue("
  UPDATE {trgtab} AS TRGTAB
    SET
      {link_key_column} = SRCTAB.{link_key_column}
    FROM {srctab} AS SRCTAB
    WHERE
     ({paste0(lookup_criteria, collapse = ') AND (')})
  ;")

locevaldb$execute_sql(update_string)

locevaldb$query_table("FieldActivityCalendar") %>%
  anti_join(
    locevaldb$query_table("Visits"),
    by = join_by(fieldactivitycalendar_id, archive_version_id)
  ) %>% nrow()


```



## LocationInfos

```{r update-locationinfos}

new_locinfos <- sample_units %>%
  distinct(
    grts_address
  ) %>%
  mutate(
    log_creator = "maintenance",
    log_creation = as.POSIXct(Sys.time()),
    log_user = "maintenance",
    log_update = as.POSIXct(Sys.time())
  )

new_locinfos <- new_locinfos %>%
  anti_join(
    locevaldb$query_table("LocationInfos"),
    by = join_by(grts_address)
  ) %>%
  left_join(
    locations_lookup,
    by = join_by(grts_address),
  )


locationinfo_lookup <- update_cascade_lookup(
  table_label = "LocationInfos",
  new_data = new_locinfos,
  index_columns = c("locationinfo_id"),
  characteristic_columns = c("grts_address"),
  tabula_rasa = FALSE,
  verbose = TRUE
)

if (FALSE) {
'
SELECT * FROM (
SELECT DISTINCT
  grts_address, 
  COUNT(DISTINCT locationinfo_id) AS n
FROM "outbound"."LocationInfos"
GROUP BY grts_address 
) WHERE n > 1;

SELECT *
FROM "outbound"."LocationInfos"
WHERE grts_address = 871030;

SELECT *
FROM "outbound"."LocationInfos"
WHERE locationinfo_id IN (
  SELECT MAX(locationinfo_id)  
  FROM "outbound"."LocationInfos"
  WHERE grts_address = 871030
);

'
}

```


## landuse

```{r update-landuse}
update_landuse_in_locationinfos(locevaldb)
```



# Replacements

## prepare
```{r stitch-replacements}

stitch_table_connection(
  mnmdb = locevaldb,
  table_label = "Replacements",
  reference_table = "SampleUnits",
  link_key_column = "sampleunit_id",
  lookup_columns = c("grts_address", "type")
)


replacement_characols = c(
    "grts_address",
    "type",
    "grts_address_replacement",
    "replacement_rank"
  )

```


## replacements archive

```{r archive-previous_replacements}

previous_replacements <- locevaldb$query_table("Replacements") %>%
  select(-wkb_geometry) %>%
  filter(
    is_inappropriate
    | is_selected
    | (!is.na(type_suggested))
    | (implications_habitatmap)
    | (!is.na(notes))
  )

replacement_archives <- previous_replacements %>%
  inner_join(
    locevaldb$query_columns(
      "SampleUnits",
      c(
        "sampleunit_id",
        "replacement_reason",
        "replacement_permanence",
        "type_is_absent"
        )
      ),
    by = join_by(sampleunit_id)
  ) %>%
  select(-replacement_id, -sampleunit_id) %>% 
  mutate(version_id = version_id)
 
glimpse(replacement_archives)


if (nrow(replacement_archives) > 0) {
  # previous_replacements %>% select(starts_with("grts_address"))

  replacement_archive_lookup <- update_cascade_lookup(
    table_label = "ReplacementArchives",
    new_data = replacement_archives,
    index_columns = c("replacementarchive_id"),
    characteristic_columns = c(
      "grts_address",
      "grts_address_replacement",
      "type",
      "replacement_rank",
      "version_id"
    ),
    tabula_rasa = FALSE,
    verbose = TRUE
  )
}
```


## restore

```{r new-replacements}

replacements <-
  stratum_schemepstargetpanel_spsamples_terr_replacementcells %>%
  select(stratum, grts_address, replacement_cells) %>%
  unnest(replacement_cells) %>%
  filter(!is.na(cellnr_replac)) %>%
  left_join(
    n2khab_strata,
    by = join_by(stratum),
    relationship = "many-to-many" # TODO
  ) %>%
  select(-stratum) %>%
  rename(
    cellnr_replacement = cellnr_replac,
    grts_address_replacement = grts_address_replac,
    replacement_rank = ranknr
  ) %>%
  inner_join(
    sampleunits_lookup %>%
      select(type, grts_address, sampleunit_id),
    by = join_by(type, grts_address),
    relationship = "many-to-many", # TODO
    unmatched = "drop"
  )



replacements_new <- replacements %>%
  left_join(
    previous_replacements,
    by = join_by(!!!rlang::syms(replacement_characols)),
    suffix = c("", "_prev")
  ) %>%
  select(-replacement_id, -sampleunit_id_prev, -cellnr_replacement) %>%
  arrange(!!!rlang::syms(replacement_characols)) %>% 
  # mutate(replacement_id = seq_len(n())) %>%
  # relocate(replacement_id)
  mutate(
    is_inappropriate = coalesce(is_inappropriate, FALSE),
    is_selected = coalesce(is_selected, FALSE),
    implications_habitatmap = coalesce(implications_habitatmap, FALSE)
  )

glimpse(replacements_new %>% filter(is_selected))

replacements_upload <- replacements_new %>%
  add_point_coords_grts(
    grts_var = "grts_address_replacement",
    spatrast = grts_mh,
    spatrast_index = grts_mh_index
  )

sf::st_geometry(replacements_upload) <- "wkb_geometry"

# glimpse(replacements_upload)


# upload new replacements, TABULA RASA
replacements_lookup <- update_cascade_lookup(
  table_label = "Replacements",
  new_data = replacements_upload,
  index_columns = c("replacement_id"),
  characteristic_columns = replacement_characols,
  tabula_rasa = TRUE,
  verbose = TRUE
)

# 'if it fails: DELETE FROM "outbound"."Replacements";'

```


## connect

```{r stitch-previous-replacements}

trgtab <- locevaldb$get_namestring("SampleUnits")
srctab <- locevaldb$get_namestring("Replacements")
lookup_columns <- c("grts_address", "type")
link_key_column <- "replacement_id"

lookup_criteria <- unlist(lapply(
  lookup_columns,
  FUN = function(col) glue::glue("TRGTAB.{col} = SRCTAB.{col}")
))

srctab_query <- glue::glue("
  SELECT {paste0(lookup_columns, collapse = ', ')}, {link_key_column}
  FROM {srctab}
  WHERE is_selected
")

# reset reference
locevaldb$execute_sql(
 glue::glue("
   UPDATE {trgtab} AS TRGTAB
     SET
       {link_key_column} = NULL;
   "),
 verbose = TRUE
)

update_string <- glue::glue("
  UPDATE {trgtab} AS TRGTAB
    SET
      {link_key_column} = SRCTAB.{link_key_column}
    FROM ({srctab_query}) AS SRCTAB
    WHERE
     ({paste0(lookup_criteria, collapse = ') AND (')})
  ;"
)

locevaldb$execute_sql(update_string, verbose = TRUE)


```

to check: `SELECT * FROM "outbound"."SampleUnits" WHERE replacement_id IS NOT NULL;`


## replacement cells

```{r new-replacement-cells}

replacement_cell_rast <-
  locevaldb$pull_column(
    "Replacements",
    "grts_address_replacement"
  ) %>%
  filter_grtsraster_by_address(spatrast = grts_mh, spatrast_index = grts_mh_index)

set.names(replacement_cell_rast, "grts_address_replacement")

replacement_cell_polygons <-
  replacement_cell_rast %>%
  as.polygons(aggregate = FALSE) %>%
  sf::st_as_sf()

replacement_cells <- replacement_cell_polygons %>%
  # to prefer the tibble approach in sf, we need to convert forth and back
  as_tibble() %>%
  mutate(grts_address_replacement = as.integer(grts_address_replacement)) %>%
  # it appears that the CRS is actually retrieved from the tibble, but I don't
  # understand how (so the crs argument below isn't needed)
  st_as_sf(crs = "EPSG:31370")

replacement_cells <-
  replacement_cells %>%
  inner_join(
    replacements_lookup,
    by = join_by(grts_address_replacement),
    relationship = "one-to-many",
    unmatched = "drop"
  ) %>%
  select(replacement_id)

sf::st_geometry(replacement_cells) <- "wkb_geometry"

message("________________________________________________________________")
message(glue::glue("DELETE/INSERT of outbound.ReplacementCells"))

locevaldb$execute_sql(
  glue::glue('DELETE  FROM "outbound"."ReplacementCells";'),
  verbose = TRUE
)

locevaldb$insert_data(
  table_label = "ReplacementCells",
  upload_data = replacement_cells
)

```

# Habitat Map Polygons aka SampleUnitPolygons

```{r update-habitatmap-polygons}

sampleunits_for_polygons <- locevaldb$query_columns(
    "SampleUnits",
    c("grts_address", "type", "sampleunit_id")
  )

sampleunit_grts_cellcenters_for_polygons <- sampleunits_for_polygons %>%
  add_point_coords_grts(
    grts_var = "grts_address",
    spatrast = grts_mh,
    spatrast_index = grts_mh_index
  )

habmap_filepath <- file.path(
    "/data/sources/bwk_2025/"
  ) # actually, using the folder path is better
# terra::vect(habmap_filepath)

habmap_unique_polygons <- terra::vect(habmap_filepath) %>%
  .[terra::vect(sampleunit_grts_cellcenters_for_polygons)] %>%
  as.polygons() %>%
  sf::st_as_sf() %>%
  st_transform(31370) %>% 
  select(geometry)

# note that polygons are multiplicated with this method if
# they contain multiple sample units.
sampleunit_polygons <- cbind(
  sampleunit_grts_cellcenters_for_polygons %>%
    sf::st_drop_geometry(),
  habmap_unique_polygons[
  sampleunit_grts_cellcenters_for_polygons %>%
    sf::st_nearest_feature(habmap_unique_polygons)
  , ]
  ) %>%
  # (FM just copied this from FV)
  # to prefer the tibble approach in sf, we need to convert forth and back
  as_tibble() %>%
  # it appears that the CRS is actually retrieved from the tibble, but I don't
  # understand how (so the crs argument below isn't needed)
  st_as_sf(crs = "EPSG:31370") %>%
  select(sampleunit_id) %>%
  anti_join(
    # filter "waiting" types
    locevaldb$query_columns(
      "FieldActivityCalendar",
      c("sampleunit_id", "wait_any")
    ) %>%
    distinct() %>% 
    filter(wait_any),
    by = join_by(sampleunit_id)
  )


sf::st_geometry(sampleunit_polygons) <- "wkb_geometry"
# mapview::mapview(sampleunit_polygons)


message("________________________________________________________________")
message(glue::glue("DELETE/INSERT of outbound.SampleUnitPolygons"))

locevaldb$execute_sql(
  glue::glue('DELETE  FROM "outbound"."SampleUnitPolygons";'),
  verbose = TRUE
)

locevaldb$insert_data(
  table_label = "SampleUnitPolygons",
  upload_data = sampleunit_polygons
)


```


# TODO


```{r step-n-safety-dump}

now <- format(Sys.time(), "%Y%m%d%H%M")
# if (isFALSE(grepl("-staging", loceval_mirror))) {
#   loceval$dump_all(
#     here::here("dumps", glue::glue("safedump_{loceval$database}_{now}.sql")),
#     exclude_schema = c("tiger", "public")
#   )
# }

if (isFALSE(grepl("-staging", locevaldb_mirror))) {
  locevaldb$dump_all(
    here::here("dumps", glue::glue("poc_post_update_{locevaldb$database}_{now}.sql")),
    exclude_schema = c("tiger", "public")
  )
}

```


```{r launch-consistency-dashboard}
system("quarto render 040l_loceval_consistency_dashboard.qmd --to html")
```

- [X] re-run the procedure.
- [X] apply to production server.
- [X] daily scripts

