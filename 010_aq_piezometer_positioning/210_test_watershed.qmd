---
title: "Watershed Area Identification"
subtitle: "Using watershed analysis to find the area of intrest for flow direction calculation"
date: "2025-11-25"
format:
  html:
    toc: true
    html-math-method: katex
    code-fold: false
    embed-resources: true
knitr:
  opts_chunk:
    echo: true
---


# The Watershed Transform

Information about this procedure might be confusing at first because two algorithm variants exist.


Take a "landscape" of quasi-continuous measurements in any dimension.
Examples are a waterlevel time series (2D landscape plot of water level x, plotted against time), a query from [DHMV](https://inbo.github.io/inbospatial/articles/spatial_dhmv_query.html) which covers elevation (z) as a function of space (x, y), or a CT scan (grey values as a function of x, y, and z).


The first variant of watershed finds all local minima, and fills the landscape from bottom to top. 
I think of it as "bottom-up" watershed.


The second variant, which leans more to the present use case, "drops" virtual water everywhere on the measurement landscape to see which way they roll. 
Sprinkling from the top, this is "top-down watershed".

Resources on the second, "top-down" variant:

+ J. Cousty, G. Bertrand, L. Najman and M. Couprie. Watershed Cuts: Minimum Spanning Forests and the Drop of Water Principle, IEEE Transactions on Pattern Analysis and Machine Intelligence 31(8) pp. 1362-1374, 2009, <https://inria.hal.science/hal-01113462/document>; <https://doi.org/10.1109/TPAMI.2008.173>
+ https://lochbihler.nl/practice-your-r-two-options-to-implement-the-watershed-segmentation/


A straight forward implementation is found in the second reference.


# Strategy

One of the feedback points we received on the first iteration of this "aquatic sample placement" analysis was that a fixed circumference around a given water body might not be correct to determine its inflow situation.
Rather, a kind of watershed analysis could be used to infer the actual area of water intake.


# Code Dev

## DHMV Query

```{r libraries}

# source(here::here("..", "R", "import_aquatic_positioning.R"))
# confirm_n2khab_data_consistency()

library("sf")
library("terra")
library("inbospatial")

```


```{R load-DHMV}
bbox <- sf::st_bbox(
   c(xmin = 148000, xmax = 149000, ymin = 208000, ymax = 209000),
   crs = sf::st_crs(31370)
)
test_raster <- inbospatial::get_coverage_wcs(
  wcs = "dhmv",
  bbox = bbox,
  layername = "DHMVII_DTM_1m",
  version = "2.0.1",
  wcs_crs = "EPSG:31370",
  resolution = 1
)

# plot(test_raster, col = gray.colors(256))
```


It might be useful to resample the surface, if at least to ensure projection of the input data onto a regular grid.

```{r resample}

n_grid <- as.integer(101)

xtnt <- sf::st_bbox(test_raster)
#     setNames(as.vector()
#   c("xmin", "xmax", "ymin", "ymax"))

coarse_grid <- terra::rast(
  nrows = n_grid, ncols = n_grid,
  xmin = xtnt[["xmin"]],
  xmax = xtnt[["xmax"]],
  ymin = xtnt[["ymin"]],
  ymax = xtnt[["ymax"]],
  )
crs(coarse_grid) <- "EPSG:31370"
test_resampled <- terra::resample(
  test_raster,
  coarse_grid,
  method = "lanczos"
  # method = "bilinear"
)
plot(test_resampled, col = gray.colors(256))
```


```{r grid-to-matrix}
test_matrix <- as.matrix(test_resampled, geom = "XY", wide = T)
# coarse_matrix <- extract(test_resampled, coarse_grid)
print(test_matrix)
```


```{r smooth}
# compute the difference of all elements of one vector to each other
self_difference <- function(vec) outer(X = vec, Y = vec, FUN = function(X, Y) Y - X )
# 
# Calculate the Euclidean distance of the x and y columns in a data frame.
Euclid <- function(x, y) sqrt(self_difference(x)^2 + self_difference(y)^2 )

# return the lower triangle of a matrix, unpacking it into a vector of unique values
lower_triangle <- function(mat) mat[lower.tri(mat)]

# smoothing 2D data
smooth <- function(data, sigma = NULL) {
  # data <- test_matrix
  # 
  
  if (sigma <= 0 || is.null(sigma) || is.na(sigma)) {
    return(data)
  }

  dist <- Euclid(seq_len(dim(data)[1]), seq_len(dim(data)[2]))
  # sigma <- extent / 3
  weight <- dnorm(dist, 0, sigma)
  weight <- weight / colSums(weight)
  # do.call("cbind", rep(list(data$z), length(data$z)))
  
  zmoothed <- weight %*% data
  return(zmoothed)
}

test_smoothed <- smooth(
  test_matrix,
  sigma = 2^3
)

x <- test_smoothed

plot(terra::rast(x), col = gray.colors(256))
```


```{r shift-matrix}
shift.vectors <- matrix(
  c(1, 1,   #1
    1, 0,   #2
    1, -1,  #3
    0, 1,   #4
    0, 0,   #5
    0, -1,  #6
    -1, 1,  #7
    -1, 0,  #8
    -1, -1),#9
    ncol = 2,
    byrow = TRUE
  )

data.shifted <- array(0.0, dim = c(dim(x)[1], dim(x)[2], 9))
for (i in 1:9) {
  data.shifted[, , i] <- magic::ashift(x, v = shift.vectors[i, ])
}
```


```{r get-direction}
data.direction <- reshape2::melt(
  apply(data.shifted, FUN = which.min, MARGIN = c(1, 2))
  )
# data.direction <- data.direction[, c(2, 1, 3)]

data.direction[data.direction[, 1] == 1, 3] <- 5
data.direction[data.direction[, 1] == dim(x)[1], 3] <- 5
data.direction[data.direction[, 2] == 1, 3] <- 5
data.direction[data.direction[, 2] == dim(x)[1], 3] <- 5

# data.direction[, 2] <- -data.direction[, 2] + max(data.direction[, 2])

flow <- terra::terrain(
    terra::rast(x),
    v = "flowdir",
    neighbors = 8
  ) %>%
  log2 %>%
  (\(x) x + 1) # %>%
  # tidyr::replace_na(0)
flow[isFALSE(is.finite(flow))] <- 0

par(mfrow = c(1, 2))
plot(terra::rast(data.direction, type = "xyz"), col = gray.colors(256))
plot(flow)
```

Note above: the `data.direction` is transposed and horizontally mirrored!


```{r iterative-move}
# generate initial coordinates for each drop of the input matrix
init.coor <- expand.grid(seq(1, dim(x)[1]), seq(1, dim(x)[2]))

# initialize, then loop and let drops flow along the gradient
changed <- TRUE
old.coor <- init.coor
new.coor <- init.coor

while (changed) {
  # calculate new coordinates
  new.coor[, 1] <-
    old.coor[, 1] - shift.vectors[data.direction[(old.coor[, 2] - 1) * dim(x)[1] + old.coor[, 1], 3], 1]
  new.coor[, 2] <-
    old.coor[, 2] - shift.vectors[data.direction[(old.coor[, 2] - 1) * dim(x)[1] + old.coor[, 1], 3], 2]

  # boundary checks
  # new.coor[new.coor[, 1] > dim(x)[1], 1] <- dim(x)[1]
  # new.coor[new.coor[, 2] > dim(x)[2], 2] <- dim(x)[2]
  # new.coor[new.coor[, 1] < 1, 1] <- 1
  # new.coor[new.coor[, 2] < 1, 2] <- 1

  # check if anything changed
  if (all(new.coor == old.coor)) {
    changed <- FALSE
  } else {
    # update old.coor for next iteration
    old.coor <- new.coor
  }
}

# plot(old.coor, col = gray.colors(256))
sinks <- old.coor

sinks <- sinks[, c(2, 1)]
sinks[, 2] <- max(sinks[, 2]) + 1 - sinks[, 2]
```

```{r}
labels <- cbind(init.coor, #[,c(2,1)],
  old.coor %>%
  dplyr::left_join(
    old.coor %>%
      dplyr::distinct() %>%
      dplyr::mutate(i = seq_len(dplyr::n())),
    by = dplyr::join_by(Var1, Var2)
  ) %>%
  dplyr::select(i) %>%
  as.matrix() 
)
labels <- labels[, c(2, 1, 3)]
labels[, 2] <- max(labels[, 2]) + 1 -labels[, 2]

par(mfrow = c(1, 2))
plot(terra::rast(x), col = gray.colors(256))
points(sinks, col = gray.colors(256))
plot(terra::rast(labels, type = "xyz"))
points(sinks, col = gray.colors(256))
```


```{r}
data.output <- matrix(0, nrow = dim(x)[1], ncol = dim(x)[2])
loc.min <- as.integer(rownames(data.direction[data.direction[, 3] == 5, c(1, 2)]))

for (i in 1:length(loc.min)) {
  data.output[seq(1, dim(x)[1] * dim(x)[2])[(old.coor[, 2] - 1) * dim(x)[1] + old.coor[, 1] == loc.min[i]]] <- i
}

par(mfrow = c(1, 2))
plot(terra::rast(x), col = gray.colors(256))
points(labels[loc.min, c(1, 2)] - 0.5)
plot(terra::rast(data.output))
points(labels[loc.min, c(1, 2)] - 0.5)
```


## terra

Oh, well, there is also a built-in function in `terra`.
<https://rspatial.github.io/terra/reference/watershed.html>

```{r shift-matrix}
#| eval: false
pourpoint <- cbind(
  mean(sf::st_bbox(test_raster)[c("xmin", "xmax")]),
  mean(sf::st_bbox(test_raster)[c("ymin", "ymax")])
)
flowdir <- terra::terrain(terra::rast(x), "flowdir")
ws <- terra::watershed(flowdir, pourpoint)

par(mfrow = c(1, 3))
plot(terra::rast(x), col = gray.colors(256))
plot(flowdir)
plot(ws)
```

... but I can't get it to work correctly.




